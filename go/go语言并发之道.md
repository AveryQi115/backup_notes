## go的并发和其他语言中并发的区别  
  
其他语言的并发：需要利用操作系统提供的线程，在操作系统层上再做一层抽象  
  
go：利用go协程，不在OS层上面抽象，而是替代OS的线程  
  
## go的并发哲学  
  
- CSP的理念：输入和输出对于一个程序来说是重要的  
  
- 不要用共享内存的方式来沟通（线程间通信），用沟通的方式来共享内存  
  
- structure ur code to make sure 一个时刻一份资源只有一个go协程在管理  
  
## goroutine概念：  
  
- thread：线程，所线程间共享内存  
  
- green thread/virtual thread：被运行库或者虚拟机管理而非OS调度的线程，他们不在核心态被管理而是在用户态  
  
- coroutine：协程，不可抢占；但是会有多个停止点（再进入点)  
  
- goroutine  
  
> - 本质上是一种协程，但是不定义自己的停止点和再进入点，而是通过go runtime管理  
  
> - goruntime会关注goroutine的运行状态并在goroutine阻塞时挂起他们；在他们不阻塞的时候恢复他们  
  
> - 所以在操作系统层面goroutine变成了可抢占的，但是他们只会在阻塞的时候被抢占（我不知道为什么这里还算是抢占调度）  
